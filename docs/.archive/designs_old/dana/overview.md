# Dana (Domain-Aware NeuroSymbolic Architecture)

## ðŸ§­ Vision

Dana is a universal program format and execution runtime that enables intelligent agents â€” human or machine â€” to reason, act, and collaborate through structured, interpretable programs.

It serves as the missing link between natural language objectives and tool-assisted, stateful action. Dana programs are concise, auditable, explainable, and can be authored by LLMs, domain experts, or both.

---

## ðŸ’¡ Motivation & Problem

Modern AI systems struggle with:

* âœ–ï¸ **Prompt chains are fragile** â€” hard to debug, hard to maintain
* âœ–ï¸ **Plans are opaque** â€” impossible to inspect or explain mid-flight
* âœ–ï¸ **Tool use is scattered** â€” logic is buried in code, not declarative programs
* âœ–ï¸ **State is implicit** â€” no shared memory model or traceable updates

Symbolic systems offer structure but lack adaptability. LLMs offer creativity but lack transparency. Dana bridges the two.

---

## âœ… Solution

Dana introduces a lightweight domain-aware program language and runtime. It allows:

* ðŸ§  **Programs as first-class reasoning artifacts**
* ðŸ“¦ **Shared state containers** (`agent`, `world`, `temp`, `execution`)
* ðŸ§© **Reusable logic units** via a structured Knowledge Base (KB)
* ðŸ§¾ **Declarative goals**, **imperative execution**
* ðŸ“œ **Bidirectional mapping to/from natural language**

Dana can:

* Be generated by a planning agent (like GMA)
* Be executed line-by-line by a runtime
* Interact with tools, LLMs, and memory
* Be stored, versioned, tested, and explained

---

## ðŸ”„ Architecture Overview

### Emitters and Interpreters of Dana

| Actor             | Type               | Role(s) in Dana            | Description                                                        |
| ----------------- | ------------------ | -------------------------- | ------------------------------------------------------------------ |
| **User (Human)**  | Person             | ðŸ–‹ Emitter                 | Writes Dana directly to define goals, logic, or KB entries         |
| **GMA**           | Agent              | ðŸ–‹ Emitter                 | General planner that emits Dana plans from objectives              |
| **DXA**           | Domain Agent       | ðŸ–‹ Emitter                 | Emits specialized domain logic/workflows, often tied to KB content |
| **KB Maintainer** | Person or Agent    | ðŸ–‹ Emitter                 | Curates reusable Dana programs as structured knowledge             |
| **Tool Resource** | System Component   | âœ… Interpreter              | Executes atomic tool-backed actions referenced in Dana             |
| **Local Runtime** | System Component   | âœ… Interpreter              | Executes Dana deterministically except for `reason(...)`           |
| **Dana_LLM**      | LLM Wrapper Module | ðŸ–‹ Emitter + âœ… Interpreter | Emits code and executes reasoning operations                       |
| **AgentRuntime**  | System Component   | ðŸ” Coordinator             | Orchestrates execution and manages delegation across all actors    |

### State Model

Dana programs operate over a shared `RuntimeContext`, which is composed of four memory scopes (state containers):

| Scope      | Description                                                      |
|------------|------------------------------------------------------------------|
| `local:`   | Local to the current agent/resource/tool/function (default scope)|
| `private:` | Private to the agent, resource, or tool itself                   |
| `public:`  | Openly accessible world state (time, weather, etc.)              |
| `system:`  | System-related mechanical state with controlled access           |

> **Note:** Only these four scopes are valid in the Dana language and enforced by the parser. Any references to other scopes (such as `agent:`, `world:`, `temp:`, `stmem:`, `ltmem:`, `execution:`, or custom scopes) are not supported in the current grammar and will result in a parse error.

### Security Design

**The `dana.runtime`